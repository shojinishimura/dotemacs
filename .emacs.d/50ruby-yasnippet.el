;;; yasnippet for ruby
;;;
;;; Shoji Nishimura (shoji_n@muc.biglobe.ne.jp)
;;; 2008/06/24

;;; snippet
(defun ruby-starting (exp)
  (string-match (concat "^\\s *" exp) (current-line-string)))

(defun ruby-required (lib)
  nil)

(yas/define-snippets
 'ruby-mode
 (reverse
 '(
   ;; General
   ("if" "if ${condition}\n  $0\nend" "if ${condition} ... end" (ruby-starting "if"))
;   ("if.q" "if ${condition}" "if qualifier" (not (ruby-starting "if")))
   ("ife" "if ${condition}\n  $0\nelse\n  \nend" "if ${condition} ... else ... end" nil)
   ("elsif" "elsif ${condition} then\n  $0" "elsif ${condition} then ..." nil)
   ("else" "else\n  $0" "else ..." nil)
   ("case" "case ${exp}\nwhen ${value}\n  $0\nend" "case ${exp} when ${value} ... end" nil)
   ("when" "when ${value}\n  $0" "when ${value} ..." nil)
   ("unless" "unless ${condition}\n  $0\nend" "unless ${condition} ... end" (ruby-starting "unless"))
;   ("unless.q" "unless ${condition}" "unless qualifier" (not (ruby-starting "unless")))
   ("while" "while ${condition}\n  $0\nend" "while ${condition} ... end" (ruby-starting "while"))
;   ("while.q" "while ${condition}" "while qualifier" (not (ruby-starting "while")))
   ("until" "until ${condition}\n  $0\nend" "until ${condition} ... end" (ruby-starting "until"))
;   ("until.q" "until ${condition}" "until qualifier" (not (ruby-starting "until")))
;   ("next" "next ${val}" "next val" nil)
;   ("break" "break" "break" nil)
;   ("redo" "redo" "redo" nil)
;   ("return" "return ${value}" "return value" nil)
   ("for" "for ${condition} in ${container}\n  $0\nend" "for ${condition} in ${container} ... end" nil)
   ("catch" "catch(:${tag}) {\n  $0\n}" "catch(:${tag}) { ... }" nil)
   ("throw" "throw :${tag}" "throw :${tag}" nil)
   ("callcc" "callcc {|${cont}|$0}" "callcc {|${cont}| ...}" nil)
   ("require" "require \"${file}\"$0" "require \"file\"" nil)
   ("reqrelative" "require File.join(File.dirname(__FILE__), ${lib})$0")
   ("def" "def ${method}\n  $0\nend" "def ${method} ... end" nil)
   ("defs" "def self.${method}\n  $0\nend" "def self.${method} ... end" nil)
   ("defi" "def initialize${args}\n  $0\nend" "def initialize${args} ... end" nil)
   ("defmm" "def method_missing(${meth}, *${args}, &${block})\n  $0\nend" "def method_missing ... end" nil)
   ("atr" "attr_reader :${attr}" "attr_reader :${attr}" nil)
   ("attr_reader" "attr_reader :${attr}" "attr_reader :${attr}" nil)
   ("atw" "attr_writer :${attr}" "attr_writer :${attr}" nil)
   ("attr_writer" "attr_writer :${attr}" "attr_writer :${attr}" nil)
   ("ata" "attr_accessor :${attr}" "attr_accessor :${attr}" nil)
   ("attr_accessor" "attr_accessor :${attr}" "attr_accessor :${attr}" nil)
   ("alias" "alias ${orig} ${new}" "alias ${orig} ${new}" nil)
   ("alias_method" "alias_method :${orig} :${new}" "alias_method :${orig} :${new}" nil)
   ("define_method" "define_method(:${name}) do${args}\n$0\nend" "define_method(:name) do ... end" nil)
   ("module_eval" "module_eval do |${mod}|\n$0\nend" "module_eval do |mod|...end" nil)
   ("class_eval" "class_eval do |${cls}|\n$0\nend" "class_eval do |cls|...end" nil)
   ("instance_eval" "instance_eval do |${obj}|\n$0\nend" "instance_eval do |obj| ... end" nil)
   ("class" "class ${ClassName}\n  $0\nend" "class ${ClassName} ... end" nil)
   ("public" "public" "public" nil)
   ("public.1" "public :${method}" "public :${method}" nil)
   ("private" "private" "private" nil)
   ("private.1" "private :${method}" "private :${method}" nil)
   ("protected" "protected" "protected" nil)
   ("protected.1" "protected :${method}" "protected :${method}" nil)
   ("module" "module ${ModuleName}\n  $0\nend" "module ${ModuleName} ... end" nil)
   ("lambda" "lambda { $0 }" "lambda { $0 }" nil)
;;   (":" ":${key} => ${value}" ":${key} => ${value}" nil)
   ("do" "do $0\nend" "do ... end" nil)
   ("begin" "begin\n  $0\nend" "begin ... end" nil)
   ("begin.1" "begin\n  $0\nensure\n\nend" "begin ... ensure ... end" nil)
   ("rescue" "rescue\n  $0" "rescue ..." (ruby-starting "rescue"))
   ("rescue.1" "rescue ${err}\n  $0" "rescue err ..." (ruby-starting "rescue"))
   ("rescue.2" "rescue => ${evar}\n  $0" "rescue => evar ..." (ruby-starting "rescue"))
   ("rescue.3" "rescue ${err} => ${evar}\n  $0" "rescue err => evar ..." (ruby-starting "rescue"))
;   ("rescue.q" "rescue ${exp}" "rescue qualifier" (not (ruby-starting "rescue")))
   ("ensure" "ensure\n  $0" "ensure ..." nil)
   ("raise" "raise" "raise" nil)
   ("raise.1" "raise \"${msg}\"" "raise \"msg\"" nil)
   ("raise.2" "raise ${err}" "raise err" nil)
   ("raise.3" "raise ${err} \"${msg}\"" "raise err \"msg\"" nil)
   ;; collections
   ("each" "each do |${e}|\n  $0\nend" "each do |e| ... end" nil)
   ("each1" "each {|${e}|$0}" "each {|e| ... } (one liner)" nil)
   ("each_index" "each_index do |${i}|\n  $0\nend" "each_index do |i| ... end" nil)
   ("each_with_index" "each_with_index do |${e}, ${i}|\n  $0\nend" "each_with_index do |e, i| ... end" nil)
   ("each_line" "each_line do |${line}|\n  $0\nend" "each_line do |line| ... end" nil)
   ("each_key" "each_key do |${key}|\n  $0\nend" "each_key do |key| ... end" nil)
   ("each_pair" "each_pair do |${key}, ${value}|\n  $0\nend" "each_pair do |key, value| ... end" nil)
   ("each_value" "each_value do |${value}|\n  $0\nend" "each_value do |value| ... end" nil)
   ("each_byte" "each_byte do |${byte}|\n  $0\nend" "each_byte do |byte| ... end" nil)
   ("inject" "inject(${init}) do |${memo}, ${item}|\n  $0\nend" "inject(init) do |memo, item| ... end" nil)
   ("inject1" "inject(${init}) {|${memo}, ${item}|$0}" "inject1(init) {|memo, item| ... } (one liner)" nil)
   ("reject" "reject do |${e}|\n  $0\nend" "reject do |e| ... end" nil)
   ("reject1" "reject {|${e}|$0}" "reject {|e| ... }" nil)
   ("map" "map do |${e}|\n  $0\nend" "map do |e| ... end" nil)
   ("map1" "map {|${e}|$0}" "map1 {|e| ...}" nil)
   ("collect" "collect do |${e}|\n  $0\nend" "collect do |e| ... end" nil)
   ("collect1" "collect {|${e}|$0}" "collect {|e| ... }" nil)
   ("select" "select do |${e}|\n  $0\nend" "select do |e| ... end" nil)
   ("select1" "select {|${e}|$0}" "select {|e| ... }" nil)
   ("find" "find do |${e}|\n  $0\nend" "find do |e| ... end" nil)
   ("find1" "find {|${e}|$0}" "fine {|e| ... }" nil)
   ("detect" "detect do |${e}|\n  $0\nend" "detect do |e| ... end" nil)
   ("detect1" "detect {|${e}|$0}" "detect1 {|e| ...}" nil)
   ("any" "any? do |${e}|\n  $0\nend" "any? do |e| ... end" nil)
   ("any1" "any? {|${e}|$0}" "any? {|e| ... }" nil)
   ("all" "all? do |${e}|\n  $0\nend" "all do |e| ... end" nil)
   ("all1" "all? {|${e}|$0}" "all {|e| ...}" nil)
   ("fill" "fill(${0..2}) do |${e}|\n  $0\nend" "fill(0..2) do |e| ... end" nil)
   ("fill1" "fill(${0..2}) {|${e}|$0}" "fill(0..2) {|e| ...}" nil)
   ("zip" "zip(${[1, 2]}) do |${row}|\n  $0\nend" "zip([1, 2]) do |row| ... end" nil)
   ("zip1" "zip(${[1, 2]}) {|${row}|$0}" "zip([1, 2]) do |row| ... end" nil)
   ("grep" "grep(${regexp}) do |${match}|\n  $0\nend" "grep(regexp) do |match| ... end" nil)
   ("grep1" "grep(${regexp}) {|${match}|$0}" "grep(regexp) {|match| ...}" nil)
   ("gsub" "gsub(${regexp}) do |${match}|\n  $0\nend" "gsub(regexp) do |match| ... end" nil)
   ("gsub1" "gsub(${regexp}) {|${match}|$0}" "gsub(regexp) {|match| ...}" nil)
   ("sub" "sub(${regexp}) do |${match}|\n  $0\nend" "sub(regexp) do |match| ... end" nil)
   ("sub1" "sub(${regexp}) {|${match}|$0}" "sub(regexp) {|match| ...}" nil)
   ("scan" "scan(${regexp}) do |${match}|\n  $0\nend" "scan(regexp) do |match| ... end" nil)
   ("scan1" "scan(${regexp}) {|${match}|$0}" "scan(regexp) {|match| ...}" nil)
   ("sort" "sort do |${a}, ${b}|\n  $0\nend" "sort do |a, b| ... end" nil)
   ("sort1" "sort {|${a}, ${b}|$0}" "sort {|a, b| ... end}" nil)
   ("sort_by" "sort_by do |${item}|\n  $0\nend" "sort_by do |item| ... end" nil)
   ("sort_by1" "sort_by {|${item}|$0}" "sort_by {|item| ...}" nil)
   ("max" "max do |${a}, ${b}|\n  $0\nend" "max do |a, b| ... end" nil)
   ("max1" "max {|${a}, ${b}|$0}" "max {|a, b| ...}" nil)
   ("min" "min do |${a}, ${b}|\n  $0\nend" "min do |a, b| ... end" nil)
   ("min1" "min {|${a}, ${b}|$0}" "min {|a, b| ...}" nil)
   ("max_by" "max_by do |${item}|\n  $0\nend" "max_by do |item| ... end" nil)
   ("max_by1" "max_by {|${item}|$0}" "max_by {|item| ...}" nil)
   ("min_by" "min_by do |${item}|\n  $0\nend" "min_by do |item| ... end" nil)
   ("min_by1" "min_by {|${item}|$0}" "min_by {|item| ...}" nil)
   ("partition" "partition do |${item}|\n  $0\nend" "partition do |item| ... end" nil)
   ("partition1" "partition {|${item}|$0}" "partition {|item| ...}" nil)
   ("Array" "Array.new" "Array.new" nil)
   ("Array.1" "Array.new(${10}) do |${i}|\n  $0\nend" "Array.new(10) do |i| ... end" nil)
   ("Array.2" "Array.new(${10}) {|${i}|$0}" "Array.new(10) {|i| ...}" nil)
   ("Hash" "Hash.new" "Hash.new" nil)
   ("Hash.1" "Hash.new do |${hash}, ${key}|\n${hash}[${key}] = $0\nend" "Hash.new do |hash, key| hash[key] = ... end" nil)
   ("Hash.2" "Hash.new {|${hash}, ${key}| ${hash}[${key}]=$0}" "Hash.new {|hash, key| hash[key]=...}" nil)
   ("times" "times do |${i}|\n  $0\nend" "times do |i| ... end" nil)
   ("times1" "times {|${i}|$0}" "times {|i| ... }" nil)
   ("upto" "upto(${10}) do |${i}|\n  $0\nend" "upto(10) do |i| ... end" nil)
   ("upto1" "upto(${10}) {|${i}|$0}" "upto(10) {|i| ...}" nil)
   ("downto" "downto(${0}) do |${i}|\n  $0\nend" "downto(0) do |i| ... end" nil)
   ("downto1" "downto(${0}) {|${i}|$0}" "downto(0) {|i| ...}" nil)
   ("step" "step(${2}) do |${n}|\n  $0\nend" "step(2) do |n| ... end" nil)
   ("step1" "step(${2}) {|${n}|$0}" "step(2) {|n| ...}" nil)
   ("open" "open(${file}) {|${io}|$0}" "open(${file}) {|io| ...}" nil)
   ("app" "if __FILE__ == \\$0\n  $0\nend" "if __FILE__ == $0 ... end" nil)
   ("tap" "tap {|s| ${p s}}" "tap {|s| ...}" nil)
;   ("rb" "#!/usr/bin/env ruby" "#!/usr/bin/env ruby" nil)
   ("BEGIN" "BEGIN {\n  $0\n}" "BEGIN { ... }" nil)
   ("END" "END {\n  $0\n}" "END { ... }" nil)
   ;; idioms
   ("Yl" "YAML.load(${str})" "YAML.load(str)" nil)
   ("Ylf" "YAML.load(${file})" "YAML.load(file)" nil)
   ("Fdf" "File.dirname(__FILE__) + \"/${filename}\"" "File.dirname(__FILE__) + filename" nil)
   ("Opt" "OptionParser.new do |opt|\n  $0\n  opt.parse!(ARGV)\nend" "OptionParser.new do |opt| end" nil)
   ("opton" "opt.on(${\"-f FILE\"}) do |file|\n $0\nend" "opt.on(\"-f FILE\") do |file| ... end" nil)
   )))